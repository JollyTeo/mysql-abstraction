// Generated by CoffeeScript 1.9.3
var Connection, assert, mysql;

assert = require('chai').assert;

mysql = require('../lib/index')({
  user: process.env.MYSQL_USER,
  host: process.env.MYSQL_HOST,
  password: process.env.MYSQL_PASSWORD,
  connectionLimit: 1,
  database: 'mysql'
});

Connection = mysql.connection;

suite('Query', function() {
  test('select', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('select-params', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT ? AS k',
      params: [1],
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('select-aliases', function(done) {
    var q;
    q = new Connection;
    return q.q({
      sql: 'SELECT ? AS k',
      values: [1],
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('lock1', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      lock: 1,
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('lock2', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      lock: 2,
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('stream', function(done) {
    var q, result, stream;
    q = new Connection;
    result = 0;
    stream = function(row) {
      return result = row.k;
    };
    return q.q({
      q: 'SELECT 1 AS k',
      lock: 2,
      stream: stream,
      cb: function() {
        assert.equal(1, result);
        return q.end(done);
      }
    });
  });
  test('end', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(function() {
          return q.end(done);
        });
      }
    });
  });
  test('endwithops', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(function() {
          return q.end({
            timeout: 30000
          }, done);
        });
      }
    });
  });
  test('commit', function(done) {
    var q;
    q = new Connection;
    return q.begin(function() {
      return q.q({
        q: 'SELECT 1 AS k',
        cb: function(err, data) {
          assert.equal(data[0].k, 1);
          return q.commit(function() {
            return q.end(done);
          });
        }
      });
    });
  });
  test('timeout', (function(_this) {
    return function(done) {
      var q;
      _this.timeout(20000);
      q = new Connection;
      q.on('error', function(err) {
        return null;
      });
      return q.begin(function() {
        return q.q({
          q: 'SELECT SLEEP(10)',
          timeout: 1,
          cb: function(err, data) {
            assert.equal(err.code, 'PROTOCOL_SEQUENCE_TIMEOUT');
            return done();
          }
        });
      });
    };
  })(this));
  test('error', function(done) {
    var q;
    q = new Connection;
    q.on('error', function() {
      return null;
    });
    return q.q({
      q: 'SELECT 1 AS k FROM no_table',
      cb: function(err, data) {
        assert.equal(err.code, 'ER_NO_SUCH_TABLE');
        return done();
      }
    });
  });
  test('streamerror', function(done) {
    var q, result, stream;
    q = new Connection;
    q.on('error', function() {
      return null;
    });
    result = 0;
    stream = function(row) {
      return result = row.k;
    };
    return q.q({
      q: 'SELECT 1 AS k FROM no_table',
      lock: 2,
      stream: stream,
      cb: function(err) {
        assert.equal(err.code, 'ER_NO_SUCH_TABLE');
        return done();
      }
    });
  });
  test('batch', function(done) {
    var q, queries;
    q = new Connection;
    queries = [];
    queries.push({
      q: 'SELECT 1 AS k'
    });
    queries.push({
      q: 'SELECT 2 AS k'
    });
    return q.batch(queries, function(err, data) {
      assert.equal(data[0][0].k, 1);
      assert.equal(data[1][0].k, 2);
      return q.end(done);
    });
  });
  test('batcherror', function(done) {
    var q, queries;
    q = new Connection;
    queries = [];
    q.on('error', function() {
      return null;
    });
    return q.batch(queries, function(err, data) {
      assert.equal(err.message, 'Cannot batch 0 queries');
      return done();
    });
  });
  test('batcherror2', function(done) {
    var q, queries;
    q = new Connection;
    q.on('error', function() {
      return null;
    });
    queries = [];
    queries.push({
      q: 'SELECT 1 AS k FROM no_table'
    });
    return q.batch(queries, function(err, data) {
      assert.equal(err.code, 'ER_NO_SUCH_TABLE');
      return done();
    });
  });
  test('enqueue', function(done) {
    var q, q2;
    q = new Connection;
    q2 = new Connection;
    mysql.pool.once('enqueue', function() {
      assert.equal(mysql.pool._connectionQueue.length, 1);
      return q.end(function() {
        return q2.end(done);
      });
    });
    return q2.begin(function() {
      return q.begin(function() {
        throw Error("Shouldn't be called");
      });
    });
  });
  test('logs', function(done) {
    var q;
    q = new Connection;
    q.log = true;
    return q.q({
      q: 'SELECT 1 AS k',
      cb: function(err, data) {
        assert.equal(q.logs[0].q, 'SELECT 1 AS k');
        return q.end(done);
      }
    });
  });
  test('row', function(done) {
    var q;
    q = new Connection;
    return q.row({
      q: 'SELECT 1 AS k',
      cb: function(err, data) {
        assert.equal(data.k, 1);
        return q.end(done);
      }
    });
  });
  test('count', function(done) {
    var q;
    q = new Connection;
    return q.count({
      q: 'SELECT count(*)',
      cb: function(err, data) {
        assert.equal(data, 1);
        return q.end(done);
      }
    });
  });
  test('warningsAreErrors', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'CREATE TEMPORARY TABLE warnings_test (test_col VARCHAR(5));',
      cb: function(err) {
        if (err) {
          throw err;
        }
        q.on('error', function() {
          return null;
        });
        return q.q({
          q: 'INSERT INTO warnings_test SET test_col="123456"',
          warningsAreErrors: true,
          cb: function(err) {
            assert.equal(err.message, 'Warnings treated as errors 1');
            assert.equal(err.warnings[0].Message, "Data truncated for column 'test_col' at row 1");
            return done();
          }
        });
      }
    });
  });
  return test('warningsAreErrorsNotEnabled', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'CREATE TEMPORARY TABLE warnings_test (test_col VARCHAR(5));',
      cb: function(err) {
        if (err) {
          throw err;
        }
        return q.q({
          q: 'INSERT INTO warnings_test SET test_col="123456"',
          cb: function(err) {
            assert.isNull(err);
            return done();
          }
        });
      }
    });
  });
});
