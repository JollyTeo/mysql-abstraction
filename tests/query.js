// Generated by CoffeeScript 1.7.1
var Connection, assert, mysql;

assert = require('chai').assert;

mysql = require('../lib/index')({
  user: process.env.MYSQL_USER,
  host: process.env.MYSQL_HOST,
  password: process.env.MYSQL_PASSWORD,
  connectionLimit: 1
});

Connection = mysql.connection;

suite('Query', function() {
  test('select', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('lock1', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      lock: 1,
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('lock2', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      lock: 2,
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(done);
      }
    });
  });
  test('stream', function(done) {
    var q, result, stream;
    q = new Connection;
    result = 0;
    stream = function(row) {
      return result = row.k;
    };
    return q.q({
      q: 'SELECT 1 AS k',
      lock: 2,
      stream: stream,
      cb: function() {
        assert.equal(1, result);
        return q.end(done);
      }
    });
  });
  test('end', function(done) {
    var q;
    q = new Connection;
    return q.q({
      q: 'SELECT 1 AS k',
      cb: function(err, data) {
        assert.equal(data[0].k, 1);
        return q.end(function() {
          return q.end(done);
        });
      }
    });
  });
  test('commit', function(done) {
    var q;
    q = new Connection;
    return q.begin(function() {
      return q.q({
        q: 'SELECT 1 AS k',
        cb: function(err, data) {
          assert.equal(data[0].k, 1);
          return q.commit(function() {
            return q.end(done);
          });
        }
      });
    });
  });
  test('error', function(done) {
    var q;
    q = new Connection;
    q.on('error', function() {});
    return q.q({
      q: 'SELECT 1 AS k FROM no_table',
      cb: function(err, data) {
        assert.equal(err.code, 'ER_NO_DB_ERROR');
        return done();
      }
    });
  });
  test('streamerror', function(done) {
    var q, result, stream;
    q = new Connection;
    q.on('error', function() {});
    result = 0;
    stream = function(row) {
      return result = row.k;
    };
    return q.q({
      q: 'SELECT 1 AS k FROM no_table',
      lock: 2,
      stream: stream,
      cb: function(err) {
        assert.equal(err.code, 'ER_NO_DB_ERROR');
        return done();
      }
    });
  });
  test('batch', function(done) {
    var q, queries;
    q = new Connection;
    queries = [];
    queries.push({
      q: 'SELECT 1 AS k'
    });
    queries.push({
      q: 'SELECT 2 AS k'
    });
    return q.batch(queries, function(err, data) {
      assert.equal(data[0][0].k, 1);
      assert.equal(data[1][0].k, 2);
      return q.end(done);
    });
  });
  test('batcherror', function(done) {
    var q, queries;
    q = new Connection;
    queries = [];
    q.on('error', function() {});
    return q.batch(queries, function(err, data) {
      assert.equal(err, 'Cannot batch 0 queries');
      return done();
    });
  });
  test('batcherror2', function(done) {
    var q, queries;
    q = new Connection;
    q.on('error', function() {});
    queries = [];
    queries.push({
      q: 'SELECT 1 AS k FROM no_table'
    });
    return q.batch(queries, function(err, data) {
      assert.equal(err.code, 'ER_NO_DB_ERROR');
      return done();
    });
  });
  test('queue', function(done) {
    var q, q2;
    q = new Connection;
    q2 = new Connection;
    q.once('queue', function(qlen) {
      assert.equal(qlen, 1);
      return q2.end(function() {
        return q.end(done);
      });
    });
    return q2.begin(function() {
      return q.begin();
    });
  });
  return test('enqueue', function(done) {
    var q, q2;
    q = new Connection;
    q2 = new Connection;
    mysql.pool.once('enqueue', function() {
      assert.equal(mysql.pool._connectionQueue.length, 1);
      return q2.end(function() {
        return q.end(done);
      });
    });
    return q2.begin(function() {
      return q.begin();
    });
  });
});
