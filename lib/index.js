// Generated by CoffeeScript 1.7.1
var deprecate, events, mysql,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

mysql = require('mysql');

events = require('events');

deprecate = require('depd')('mysql-abstraction');

module.exports = function(settings) {
  var Connection, pool;
  pool = mysql.createPool(settings);
  return {
    pool: pool,
    connection: Connection = (function(_super) {
      __extends(Connection, _super);

      function Connection(autoStartTransaction) {
        this.autoStartTransaction = autoStartTransaction != null ? autoStartTransaction : false;
        this.hasTransaction = false;
        this.connection = null;
      }

      Connection.prototype.connect = function(cb) {
        pool.setMaxListeners(0);
        pool.on('enqueue', (function(_this) {
          return function() {
            if (_this.listeners('queue').length) {
              deprecate("The 'queue' event for 'connection' is deprecated, please listen to the 'enqueue' event of 'pool', to obtain the queue length use 'pool._connectionQueue.length'");
            }
            return _this.emit('queue', pool._connectionQueue.length);
          };
        })(this));
        return pool.getConnection((function(_this) {
          return function(err, connection) {
            _this.connection = connection;
            _this.lastQuery = null;
            if (err) {
              _this.emit('error', err);
            }
            return cb(err);
          };
        })(this));
      };

      Connection.prototype.error = function(err, cb) {
        var end;
        if (settings.logErrors != null) {
          err.query = this.lastQuery;
          settings.logErrors(err);
        }
        end = (function(_this) {
          return function() {
            _this.emit('error', err);
            if (cb != null) {
              return cb(err);
            }
          };
        })(this);
        if (this.connection) {
          this.connection.on('error', function() {});
          return this.connection.query('ROLLBACK', (function(_this) {
            return function(err) {
              _this.connection._purge = true;
              _this.connection.release();
              _this.connection = null;
              return end();
            };
          })(this));
        } else {
          return process.nextTick(end);
        }
      };

      Connection.prototype.q = function(ops) {
        var query, run;
        query = (function(_this) {
          return function() {
            var streamError;
            ops.cb = ops.cb || ops.callback || function() {};
            ops.params = ops.params || [];
            streamError = null;
            if (ops.lock != null) {
              ops.q += ops.lock === 1 ? ' LOCK IN SHARE MODE' : ' FOR UPDATE';
            }
            if (ops.stream != null) {
              _this.lastQuery = query = _this.connection.query(ops.q, ops.params);
              query.on('error', function(err) {
                return streamError = err;
              });
              query.on('result', function(row) {
                return ops.stream(row);
              });
              return query.on('end', function() {
                if (streamError != null) {
                  return _this.error(streamError, ops.cb);
                }
                return ops.cb();
              });
            } else {
              return _this.lastQuery = _this.connection.query(ops.q, ops.params, function(err, data) {
                if (err) {
                  return _this.error(err, ops.cb);
                } else {
                  return ops.cb(null, data);
                }
              });
            }
          };
        })(this);
        run = (function(_this) {
          return function() {
            if (!_this.hasTransaction && (_this.autoStartTransaction || (ops.lock != null))) {
              return _this.begin(function() {
                return query();
              });
            } else {
              return query();
            }
          };
        })(this);
        if (this.connection == null) {
          return this.connect((function(_this) {
            return function() {
              return run();
            };
          })(this));
        } else {
          return run();
        }
      };

      Connection.prototype.begin = function(cb) {
        this.hasTransaction = true;
        return this.q({
          q: 'START TRANSACTION',
          cb: function() {
            return cb();
          }
        });
      };

      Connection.prototype.commit = function(cb) {
        return this.q({
          q: 'COMMIT',
          cb: (function(_this) {
            return function() {
              _this.hasTransaction = false;
              return cb();
            };
          })(this)
        });
      };

      Connection.prototype.end = function(cb) {
        if (this.connection == null) {
          if (cb != null) {
            process.nextTick(cb);
          }
          return;
        }
        if (this.hasTransaction) {
          return this.q({
            q: 'COMMIT',
            cb: (function(_this) {
              return function(err) {
                _this.connection.release();
                _this.connection = null;
                if (cb != null) {
                  return cb(err);
                }
              };
            })(this)
          });
        } else {
          this.connection.release();
          this.connection = null;
          if (cb != null) {
            return process.nextTick(cb);
          }
        }
      };

      Connection.prototype.batch = function(queries, cb) {
        var executed, results, run;
        if (queries.length === 0) {
          return this.error("Cannot batch 0 queries", cb);
        }
        results = [];
        executed = 1;
        run = (function(_this) {
          return function(err, res) {
            results.push(res);
            if (err) {
              return cb(err, results);
            }
            if (queries.length > executed) {
              queries[executed].cb = run;
              _this.q(queries[executed]);
              return executed += 1;
            } else {
              return cb(null, results);
            }
          };
        })(this);
        queries[0].cb = run;
        return this.q(queries[0]);
      };

      return Connection;

    })(events.EventEmitter)
  };
};
