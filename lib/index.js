// Generated by CoffeeScript 2.3.2
var async, events, mysql;

mysql = require('mysql');

events = require('events');

async = require('async');

module.exports = function(settings) {
  var Connection, pool;
  pool = mysql.createPool(settings);
  return {
    pool: pool,
    connection: Connection = class Connection extends events.EventEmitter {
      constructor(autoStartTransaction = false) {
        super();
        this.autoStartTransaction = autoStartTransaction;
        this.gatherStats = true;
        this.log = false;
        this.logs = [];
        this.maxRetries = 3;
        this.connectionRetries = 4;
        this.connectionRetryInterval = 500;
        this._reset();
      }

      _reset() {
        this.hasTransaction = false;
        this.connection = null;
        this.logs = [];
        this._returnConnection = null;
        this.queries = [];
        this.retries = 0;
        this.connectionAttempts = 0;
        this.lastQuery = null;
        this.lastOps = null;
        return this.stats = {
          select: 0,
          update: 0,
          delete: 0,
          insert: 0
        };
      }

      connect(cb) {
        this.connectionAttempts += 1;
        this._returnConnection = (err, connection) => {
          if (err) {
            if (this.connectionAttempts >= this.connectionRetries) {
              this.emit('error', err);
              return cb(err);
            } else {
              return setTimeout(() => {
                return this.connect(cb);
              }, this.connectionRetryInterval);
            }
          } else {
            this.connection = connection;
            return cb(err);
          }
        };
        return pool.getConnection(this._returnConnection);
      }

      error(err, cb) {
        var end, ref;
        //deadlock, reissue query
        err.query = this.lastQuery;
        if (((ref = err.code) === 'ER_LOCK_DEADLOCK' || ref === 'ER_LOCK_WAIT_TIMEOUT') && this.retries < this.maxRetries) {
          this.retries += 1;
          this.emit('deadlock', err);
          this.hasTransaction = false;
          return async.eachSeries(this.queries, (query, c) => {
            return this.q({
              q: query.q,
              params: query.params,
              retry: true,
              cb: c
            });
          }, cb);
        }
        if (settings.logErrors != null) {
          settings.logErrors(err);
        }
        end = () => {
          this.emit('error', err);
          if (cb != null) {
            return cb(err);
          }
        };
        if (this.connection) {
          return this.connection.query('ROLLBACK', (err) => {
            this.connection._purge = true;
            this.connection.release();
            this.connection = null;
            return end();
          });
        } else {
          return process.nextTick(end);
        }
      }

      q(ops) {
        var query, run;
        if (this.log) {
          this.logs.push(ops);
        }
        this.lastOps = ops;
        ops.cb = ops.cb || ops.callback;
        ops.values = ops.values || ops.params || [];
        ops.sql = ops.sql || ops.q;
        query = () => {
          var i, len, ref, stat, streamError;
          /*
          #This is crude and doesn't support complex queries i.e. UPDATE .... SELECT
          #But it does the job for most cases
           */
          if (this.gatherStats) {
            ref = Object.keys(this.stats);
            for (i = 0, len = ref.length; i < len; i++) {
              stat = ref[i];
              if (ops.sql.toLowerCase().indexOf(stat) !== -1) {
                this.stats[stat] += 1;
              }
            }
          }
          streamError = null;
          if (ops.lock != null) {
            ops.sql += ops.lock === 1 ? ' LOCK IN SHARE MODE' : ' FOR UPDATE';
          }
          if (!ops.retry) {
            this.queries.push({
              q: ops.q,
              params: ops.params
            });
          }
          if (ops.stream != null) {
            this.lastQuery = query = this.connection.query(ops.sql, ops.params);
            query.on('error', function(err) {
              return streamError = err;
            });
            query.on('result', function(row) {
              return ops.stream(row);
            });
            return query.on('end', () => {
              if (streamError != null) {
                return this.error(streamError, ops.cb);
              }
              return ops.cb();
            });
          } else {
            return this.lastQuery = this.connection.query(ops, (err, data) => {
              if (ops.warningsAreErrors && (data != null ? data.warningCount : void 0) > 0) {
                return this.connection.query('SHOW WARNINGS', (err, warnings) => {
                  var error;
                  if (err) {
                    return this.error(err, ops.cb);
                  } else {
                    error = new Error('Warnings treated as errors ' + data.warningCount);
                    error.warnings = warnings;
                    return this.error(error, ops.cb);
                  }
                });
              } else if (err) {
                return this.error(err, ops.cb);
              } else {
                return ops.cb(null, data);
              }
            });
          }
        };
        run = () => {
          if (!this.hasTransaction && (this.autoStartTransaction || (ops.lock != null))) {
            return this.begin(function(err) {
              if (err) {
                return ops.cb(err);
              }
              return query();
            });
          } else {
            return query();
          }
        };
        if (this.connection == null) {
          return this.connect(function(err) {
            if (err) {
              return ops.cb(err);
            }
            return run();
          });
        } else {
          return run();
        }
      }

      row(ops) {
        var cb;
        cb = ops.cb;
        [cb, ops.cb] = [
          ops.cb,
          function(err,
          data) {
            return cb(err,
          data != null ? data[0] : void 0);
          }
        ];
        return this.q(ops);
      }

      count(ops) {
        var cb;
        cb = ops.cb;
        [cb, ops.cb] = [
          ops.cb,
          function(err,
          data) {
            return cb(err,
          data != null ? data[0][Object.keys(data != null ? data[0] : void 0)[0]] : void 0);
          }
        ];
        return this.q(ops);
      }

      begin(cb) {
        this.hasTransaction = true;
        return this.q({
          q: 'START TRANSACTION',
          cb: function() {
            return cb();
          }
        });
      }

      commit(ops, cb) {
        if (cb == null) {
          [cb, ops] = [ops, {}];
        }
        return this.q({
          q: 'COMMIT',
          timeout: ops.timeout,
          cb: () => {
            this.hasTransaction = false;
            return cb();
          }
        });
      }

      end(ops, cb) {
        var index;
        if (arguments.length === 1) {
          cb = ops;
          ops = {};
        }
        if (this.connection == null) {
          index = pool._connectionQueue.indexOf(this._returnConnection);
          if (index !== -1) {
            pool._connectionQueue.splice(index, 1);
          }
          this._reset();
          return process.nextTick(cb);
        } else if (this.hasTransaction) {
          return this.commit(ops, (err) => {
            this.connection.release();
            this._reset();
            return cb(err);
          });
        } else {
          this.connection.release();
          this._reset();
          return process.nextTick(cb);
        }
      }

      batch(queries, cb) {
        var executed, results, run;
        if (queries.length === 0) {
          return this.error(new Error("Cannot batch 0 queries"), cb);
        }
        results = [];
        executed = 1;
        run = (err, res) => {
          results.push(res);
          if (err) {
            return cb(err, results);
          }
          if (queries.length > executed) {
            queries[executed].cb = run;
            this.q(queries[executed]);
            return executed += 1;
          } else {
            return cb(null, results);
          }
        };
        queries[0].cb = run;
        return this.q(queries[0]);
      }

    }
  };
};
